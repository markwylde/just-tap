(() => {
  // ../lib/waitUntil.js
  var waitUntil = async function(fn, timeout) {
    const result = await fn();
    if (result) {
      return result;
    }
    return new Promise((resolve, reject) => {
      const timeoutTimer = timeout && setTimeout(() => finish(null, true), timeout);
      const retryTimer = setInterval(async () => {
        try {
          const result2 = await fn();
          if (result2) {
            finish(result2, false);
          }
        } catch (error) {
        }
      });
      function finish(result2, didTimeOut) {
        clearTimeout(timeoutTimer);
        clearInterval(retryTimer);
        if (didTimeOut) {
          reject(result2);
        } else {
          resolve(result2);
        }
      }
    });
  };
  var waitUntil_default = waitUntil;

  // ../lib/index.js
  var defaultOptions = {
    logger: console.log,
    concurrency: Infinity,
    formatInfo: (text) => `\x1B[96m${text}\x1B[0m`,
    formatDanger: (text) => `\x1B[91m${text}\x1B[0m`,
    formatSuccess: (text) => `\x1B[92m${text}\x1B[0m`
  };
  var runTest = async (context, test) => {
    const { options, stats } = context;
    const local = {
      log: [
        options.formatInfo(`# ${test.name}:`)
      ],
      failed: false,
      finished: false,
      planned: null,
      assertions: 0,
      timeout: null,
      notOk: (message) => {
        if (local.finished) {
          throw Object.assign(new Error("assertion was made on a finished test"), { testName: test.name });
        }
        local.assertions = local.assertions + 1;
        stats.notOk = stats.notOk + 1;
        local.failed = true;
        local.log.push(`${options.formatDanger("not ok")} ${stats.ok + stats.notOk} - ${message}`);
      },
      ok: (message) => {
        if (local.finished) {
          throw Object.assign(new Error("assertion was made on a finished test"), { testName: test.name });
        }
        local.assertions = local.assertions + 1;
        stats.ok = stats.ok + 1;
        local.log.push(`${options.formatSuccess("ok")} ${stats.ok + stats.notOk} - ${message}`);
      }
    };
    await test.fn({
      plan: (newPlan) => {
        local.planned = newPlan;
      },
      timeout: (newTimeout) => {
        local.timeout = newTimeout;
      },
      pass: (message) => {
        message = message || "passed";
        local.ok(message);
      },
      fail: (message) => {
        message = message || "failed";
        local.notOk(message);
      },
      equal: (a, b, message) => {
        message = message || `expected "${a}" to equal "${b}"`;
        if (a === b) {
          local.ok(message);
        } else {
          local.notOk(message);
        }
      },
      notEqual: (a, b, message) => {
        message = message || `expected "${a}" to not equal "${b}"`;
        if (a !== b) {
          local.ok(message);
        } else {
          local.notOk(message);
        }
      },
      looseEqual: (a, b, message) => {
        message = message || `expected "${a}" to loose equal "${b}"`;
        if (a == b) {
          local.ok(message);
        } else {
          local.notOk(message);
        }
      },
      notLooseEqual: (a, b, message) => {
        message = message || `expected "${a}" to not loose equal "${b}"`;
        if (a != b) {
          local.ok(message);
        } else {
          local.notOk(message);
        }
      },
      deepEqual: (a, b, message) => {
        const stringA = JSON.stringify(a);
        const stringB = JSON.stringify(b);
        message = message || `expected ${stringA} to deep equal ${stringB}`;
        if (stringA === stringB) {
          local.ok(message);
        } else {
          local.notOk(message);
        }
      },
      notDeepEqual: (a, b, message) => {
        const stringA = JSON.stringify(a);
        const stringB = JSON.stringify(b);
        message = message || `expected ${stringA} to not deep equal ${stringB}`;
        if (stringA !== stringB) {
          local.ok(message);
        } else {
          local.notOk(message);
        }
      },
      ok: (result, message) => {
        message = message || `expected "${result}" to be truthy`;
        if (result) {
          local.ok(message);
        } else {
          local.notOk(message);
        }
      },
      notOk: (result, message) => {
        message = message || `expected "${result}" to be falsy`;
        if (!result) {
          local.ok(message);
        } else {
          local.notOk(message);
        }
      }
    });
    try {
      local.planned && await waitUntil_default(() => {
        return local.assertions >= local.planned;
      }, local.timeout);
      if (local.planned && local.assertions !== local.planned) {
        local.notOk(`expected assertions to be as planned (planned="${local.planned}", assertions="${local.assertions}")`);
      }
    } catch (error) {
      local.notOk(`timed out waiting for assertions to be as planned (planned="${local.planned}", assertions="${local.assertions}")`);
    }
    if (local.failed) {
      stats.failed = stats.failed + 1;
    } else {
      stats.passed = stats.passed + 1;
    }
    local.finished = true;
    options.logger(local.log.join("\n"));
  };
  var run = async (context) => {
    const options = context.options;
    options.logger("TAP version 14");
    context.stats = {
      passed: 0,
      failed: 0,
      ok: 0,
      notOk: 0,
      skipped: context.skipped.length
    };
    const tests = context.only.length > 0 ? context.only : context.tests;
    const promises = [];
    let running = 0;
    for (const test of tests) {
      running = running + 1;
      promises.push(
        runTest(context, test).then(() => {
          running = running - 1;
        })
      );
      await waitUntil_default(() => running < options.concurrency);
    }
    await Promise.all(promises);
    options.logger("");
    options.logger("1.." + (context.stats.ok + context.stats.notOk));
    options.logger("# tests " + (context.stats.ok + context.stats.notOk));
    options.logger("# pass  " + context.stats.ok);
    options.logger("# fail  " + context.stats.notOk);
    options.logger("# skip  " + context.stats.skipped);
    context.stats.success = context.stats.notOk === 0 && context.stats.failed === 0;
    return context.stats;
  };
  function createTestSuite(options = {}) {
    options = { ...defaultOptions, ...options };
    const context = {
      options,
      tests: [],
      only: [],
      skipped: []
    };
    const test = (name, fn) => {
      context.tests.push({ name, fn });
    };
    test.skip = (name, fn) => {
      context.skipped.push({ name, fn });
    };
    test.only = (name, fn) => {
      context.only.push({ name, fn });
    };
    return {
      test,
      run: run.bind(null, context)
    };
  }

  // worker.js
  self.realCreateTestSuite = createTestSuite;
  self.addEventListener("error", (error) => {
    self.postMessage(["error", error.message]);
  });
  self.addEventListener("message", async (event) => {
    try {
      const pre = `
      const realConsole = self.console;
      const console = {
        log: (...args) => {
          realConsole.log(...args);
          self.postMessage(['log', args]);
        }
      };
      
      const createTestSuite = (options) => {
        return realCreateTestSuite({
          logger: console.log,
          ...options
        })
      }
    `;
      await (0, eval)(`
      (async () => {
        ${pre + event.data}
      })();
    `);
      self.postMessage(["finish"]);
    } catch (error) {
      self.postMessage(["error", error.message]);
    }
  });
})();
